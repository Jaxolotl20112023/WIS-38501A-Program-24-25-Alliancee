{"mode":"Text","hardwareTarget":"brain","textContent":"#pragma region VEXcode Generated Robot Configuration\n// Make sure all required headers are included.\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <math.h>\n#include <string.h>\n\n\n#include \"vex.h\"\n\nusing namespace vex;\n\n// Brain should be defined by default\nbrain Brain;\n\n\n// START V5 MACROS\n#define waitUntil(condition)                                                   \\\n  do {                                                                         \\\n    wait(5, msec);                                                             \\\n  } while (!(condition))\n\n#define repeat(iterations)                                                     \\\n  for (int iterator = 0; iterator < iterations; iterator++)\n// END V5 MACROS\n\n\n// Robot configuration code.\nmotor leftMotorA = motor(PORT17, ratio18_1, false);\nmotor leftMotorB = motor(PORT16, ratio18_1, false);\nmotor_group LeftDriveSmart = motor_group(leftMotorA, leftMotorB);\nmotor rightMotorA = motor(PORT19, ratio18_1, true);\nmotor rightMotorB = motor(PORT18, ratio18_1, true);\nmotor_group RightDriveSmart = motor_group(rightMotorA, rightMotorB);\ninertial DrivetrainInertial = inertial(PORT6);\nsmartdrive Drivetrain = smartdrive(LeftDriveSmart, RightDriveSmart, DrivetrainInertial, 319.19, 320, 40, mm, 1);\n\nmotor SwingArm = motor(PORT1, ratio36_1, true);\n\nrotation RotationSens = rotation(PORT8, false);\n\nmotor Intake = motor(PORT20, ratio18_1, false);\n\ncontroller Controller1 = controller(primary);\ndigital_out Clamp = digital_out(Brain.ThreeWirePort.H);\n/*vex-vision-config:begin*/\nvision::signature VisionSens__RED_RING = vision::signature (1, 4477, 7521, 5999,-365, 857, 246,2.5, 0);\nvision VisionSens = vision (PORT21, 10, VisionSens__RED_RING);\n/*vex-vision-config:end*/\nlimit Conveyor_Switch = limit(Brain.ThreeWirePort.A);\nmotor ConveyorMotorA = motor(PORT2, ratio18_1, false);\nmotor ConveyorMotorB = motor(PORT10, ratio18_1, true);\nmotor_group Conveyor = motor_group(ConveyorMotorA, ConveyorMotorB);\n\n\n\n// generating and setting random seed\nvoid initializeRandomSeed(){\n  int systemTime = Brain.Timer.systemHighResolution();\n  double batteryCurrent = Brain.Battery.current();\n  double batteryVoltage = Brain.Battery.voltage(voltageUnits::mV);\n\n  // Combine these values into a single integer\n  int seed = int(batteryVoltage + batteryCurrent * 100) + systemTime;\n\n  // Set the seed\n  srand(seed);\n}\n\nbool vexcode_initial_drivetrain_calibration_completed = false;\nvoid calibrateDrivetrain() {\n  wait(200, msec);\n  Brain.Screen.print(\"Calibrating\");\n  Brain.Screen.newLine();\n  Brain.Screen.print(\"Inertial\");\n  DrivetrainInertial.calibrate();\n  while (DrivetrainInertial.isCalibrating()) {\n    wait(25, msec);\n  }\n  vexcode_initial_drivetrain_calibration_completed = true;\n  // Clears the screen and returns the cursor to row 1, column 1.\n  Brain.Screen.clearScreen();\n  Brain.Screen.setCursor(1, 1);\n}\n\nvoid vexcodeInit() {\n\n  // Calibrate the Drivetrain\n  calibrateDrivetrain();\n\n  //Initializing random seed.\n  initializeRandomSeed(); \n}\n\n\n// Helper to make playing sounds from the V5 in VEXcode easier and\n// keeps the code cleaner by making it clear what is happening.\nvoid playVexcodeSound(const char *soundName) {\n  printf(\"VEXPlaySound:%s\\n\", soundName);\n  wait(5, msec);\n}\n\n\n\n// define variable for remote controller enable/disable\nbool RemoteControlCodeEnabled = true;\n// define variables used for controlling motors based on controller inputs\nbool DrivetrainLNeedsToBeStopped_Controller1 = true;\nbool DrivetrainRNeedsToBeStopped_Controller1 = true;\n\n// define a task that will handle monitoring inputs from Controller1\nint rc_auto_loop_function_Controller1() {\n  // process the controller input every 20 milliseconds\n  // update the motors based on the input values\n  while(true) {\n    if(RemoteControlCodeEnabled) {\n      // stop the motors if the brain is calibrating\n      if (DrivetrainInertial.isCalibrating()) {\n        LeftDriveSmart.stop();\n        RightDriveSmart.stop();\n        while (DrivetrainInertial.isCalibrating()) {\n          wait(25, msec);\n        }\n      }\n      \n      // calculate the drivetrain motor velocities from the controller joystick axies\n      // left = Axis3\n      // right = Axis2\n      int drivetrainLeftSideSpeed = Controller1.Axis3.position();\n      int drivetrainRightSideSpeed = Controller1.Axis2.position();\n      \n      // check if the value is inside of the deadband range\n      if (drivetrainLeftSideSpeed < 5 && drivetrainLeftSideSpeed > -5) {\n        // check if the left motor has already been stopped\n        if (DrivetrainLNeedsToBeStopped_Controller1) {\n          // stop the left drive motor\n          LeftDriveSmart.stop();\n          // tell the code that the left motor has been stopped\n          DrivetrainLNeedsToBeStopped_Controller1 = false;\n        }\n      } else {\n        // reset the toggle so that the deadband code knows to stop the left motor nexttime the input is in the deadband range\n        DrivetrainLNeedsToBeStopped_Controller1 = true;\n      }\n      // check if the value is inside of the deadband range\n      if (drivetrainRightSideSpeed < 5 && drivetrainRightSideSpeed > -5) {\n        // check if the right motor has already been stopped\n        if (DrivetrainRNeedsToBeStopped_Controller1) {\n          // stop the right drive motor\n          RightDriveSmart.stop();\n          // tell the code that the right motor has been stopped\n          DrivetrainRNeedsToBeStopped_Controller1 = false;\n        }\n      } else {\n        // reset the toggle so that the deadband code knows to stop the right motor next time the input is in the deadband range\n        DrivetrainRNeedsToBeStopped_Controller1 = true;\n      }\n      \n      // only tell the left drive motor to spin if the values are not in the deadband range\n      if (DrivetrainLNeedsToBeStopped_Controller1) {\n        LeftDriveSmart.setVelocity(drivetrainLeftSideSpeed, percent);\n        LeftDriveSmart.spin(forward);\n      }\n      // only tell the right drive motor to spin if the values are not in the deadband range\n      if (DrivetrainRNeedsToBeStopped_Controller1) {\n        RightDriveSmart.setVelocity(drivetrainRightSideSpeed, percent);\n        RightDriveSmart.spin(forward);\n      }\n    }\n    // wait before repeating the process\n    wait(20, msec);\n  }\n  return 0;\n}\n\ntask rc_auto_loop_task_Controller1(rc_auto_loop_function_Controller1);\n\n#pragma endregion VEXcode Generated Robot Configuration\n\n// ----------------------------------------------------------------------------\n//                                                                            \n//    Project:                                               \n//    Author:\n//    Created:\n//    Configuration:        \n//                                                                            \n// ----------------------------------------------------------------------------\n\n// Include the V5 Library\n#include \"vex.h\"\n\n// Allows for easier use of the VEX Library\nusing namespace vex;\n\n// Begin project code\n\nvoid preAutonomous(void) {\n  // actions to do when the program starts\n  Brain.Screen.clearScreen();\n  Brain.Screen.print(\"pre auton code\");\n  wait(1, seconds);\n}\n\nvoid ClampDown() {\n  Clamp.set(true);\n}\n\nvoid ClampUp() {\n  Clamp.set(false); \n}\n\nbool switch_arm_intake(bool switchButton) {\n  switchButton = !switchButton; \n  return switchButton; \n}\n\n\nvoid intake_and_arm(bool switchButton) {\n  if (Controller1.ButtonR1.pressing() == true && switchButton == false) {\n      Intake.spin(forward);\n    } else if (Controller1.ButtonR1.pressing() == false && switchButton == false) {\n      if (Controller1.ButtonR2.pressing() == true && switchButton == false) {\n        Intake.spin(reverse); \n      } else {\n        Intake.stop();\n      } \n\n  }\n\n  if (Controller1.ButtonR1.pressing() == true && switchButton == true){\n      SwingArm.spin(forward); \n    } else if (Controller1.ButtonR1.pressing() == false && switchButton == true){\n      if (Controller1.ButtonR2.pressing() == true) {\n        SwingArm.spin(reverse); \n      } else {\n        SwingArm.stop(); \n      }\n    }\n}\n\n\n\n\nvoid autonomous(void) {\n  Brain.Screen.clearScreen();\n  Brain.Screen.print(\"autonomous code\");\n  // place automonous code here\n}\n\nvoid userControl(void) {\n  Brain.Screen.clearScreen();\n  // place driver control in this while loop\n  Conveyor.setVelocity(100, percent); \n  SwingArm.setVelocity(60, percent); \n  Intake.setVelocity(100, percent); \n  Drivetrain.setDriveVelocity(100, percent);\n  Drivetrain.setTurnVelocity(100, percent); \n\n  Conveyor.setPosition(0,degrees); \n  SwingArm.setPosition(0, degrees); \n  RotationSens.setPosition(0,degrees);\n  SwingArm.setStopping(hold); \n  bool redEvent = false; \n  bool activate = false;\n  int number_of_object;  \n  bool buttonXState = false; \n  bool State = false;\n\n  //bool store_objects[3];\n\n  while (true) {\n    Controller1.ButtonUp.pressed(ClampUp);\n    Controller1.ButtonDown.pressed(ClampDown); \n\n    //CHECKS WHEN BUTTON X IS RELEASED\n    if (!Controller1.ButtonX.pressing() && buttonXState) {\n      State = switch_arm_intake(buttonXState); //CALLS AND ASSIGNS THE FUNC THAT WILL TOGGLE BUTTONX ON AND OFF\n      buttonXState = false;             //SETS THE STATE BACK TO FALSE\n      intake_and_arm(State);           //CHECKS IF THE R2 OR R1 IS PRESSED AND SWITCHES BETWEEN ARM AND INTAKE\n    }\n    if (Controller1.ButtonX.pressing() == true){\n      if (buttonXState == false) {\n        intake_and_arm(true);           //CHECKS IF THE R2 OR R1 IS PRESSED AND SWITCHES BETWEEN ARM AND INTAKE\n      }\n      buttonXState = true;              //SETS THE STATE BACK TO TRUE\n    } else {\n      intake_and_arm(State);           //CHECKS IF THE R2 OR R1 IS PRESSED AND SWITCHES BETWEEN ARM AND INTAKE\n    }\n\n\n    //STARTS SCANNING AND MOVING THE CONVEYOR TO FIND RED RINGS\n    if (Controller1.ButtonL1.pressing() == true && Controller1.ButtonL2.pressing() == false && redEvent == false)  {\n      Conveyor.spin(forward);           //SPINS CONVEYOR IN REVERSE WHEN PRESSING L1\n      Brain.Screen.print(\"REVERSE :0\");\n    } else if (Controller1.ButtonL1.pressing() == false && Controller1.ButtonL2.pressing() == true && redEvent == false) {\n      Conveyor.spin(reverse);           //SPINS CONVEYOR FORWARD WHEN PRESSING L2\n      VisionSens.takeSnapshot(VisionSens__RED_RING); //TAKES A SNAPSHOT OF THE AREA TO CHECK IF THERE ARE ANY RED RINGS\n    } else {\n      Conveyor.stop();                  //IF NEITHER BUTTONS ARE BEING PRESSED IT WILL STOP AND RESET THE REDEVENT TO FALSE\n      Brain.Screen.print(\"STOP\"); \n      redEvent = false;\n      VisionSens.takeSnapshot(VisionSens__RED_RING); //IT WILL TAKE A SNAPSHOT TO HAVE A CONTINOUS UP\n\n    }\n    Brain.Screen.clearScreen(); \n\n    //if see the ring, tell the code I saw the ring\n    if (VisionSens.largestObject.width >= 60 && redEvent == false) {\n      redEvent = true;\n      number_of_object++; \n    }\n\n    //WHEN IT SEES A RED RING AND L2 IS BEING PRESSED IT WILL ACTIVATE THE FLIPPING PART\n    if (redEvent == true && Controller1.ButtonL2.pressing() && !Controller1.ButtonL1.pressing()){\n      Brain.Screen.print(\"SEE RED & FLING\");\n      while (!Conveyor_Switch.pressing()) {        //CHECKS IF THE LIMIT SWITCH IS BEING PRESSED (N -> CONVEYOR REVERSE, Y, GET READY TO FLING)\n          Conveyor.spin(reverse);\n        }\n        Brain.Screen.print(\"CLICK\"); \n        if (activate == false) {                   //CHECKS IF THE DISABLEDED SAFTEY SWITCH IS ON\n          Brain.Screen.print(\"RED SAW\");           //WAITS 0.49 SECONDS, THE TIME THE RING TAKES TO REACH THE TOP\n            wait(0.49, seconds);                   //STOPS AFTER 0.49 SECONDS\n            Conveyor.stop();                \n            wait(1, seconds);                      //WAIT 1 SECOND BEFORE RE-ACTIVATING THE CONVEYOR\n            redEvent = false;                      //RESET THE REDEVENT BACK TO FALSE\n            number_of_object = 0; \n            Brain.Screen.newLine(); \n            Brain.Screen.print(\"RED THROUGH\");\n          \n        }\n    }\n\n\n    // // if intaking  and it saw the ring,\n    // //do the fling sequence\n    // if ((Controller1.ButtonL2.pressing() == true && Controller1.ButtonL1.pressing() == false) && redEvent == true) {\n    //     while (!Conveyor_Switch.pressing()) {\n    //       Conveyor.spin(reverse);\n    //     }\n    //     if (activate == false) {\n    //       Brain.Screen.print(\"RED SAW\");\n    //       wait(0.5, seconds); \n    //       Conveyor.stop();\n    //       wait(0.5, seconds); \n    //       redEvent = false;\n    //       Brain.Screen.newLine(); \n    //       Brain.Screen.print(\"RED THROUGH\"); \n    //     }\n    // }\n    wait(10, msec);\n  }\n}\n\nint main() {\n  // Initializing Robot Configuration. DO NOT REMOVE!\n  vexcodeInit();\n  // create competition instance\n  competition Competition;\n\n  // Set up callbacks for autonomous and driver control periods.\n  Competition.autonomous(autonomous);\n  Competition.drivercontrol(userControl);\n\n  // Run the pre-autonomous function.\n  preAutonomous();\n\n  // Prevent main from exiting with an infinite loop.\n  while (true) {\n    userControl(); \n    wait(20, msec);\n  }\n}","textLanguage":"cpp","robotConfig":[{"port":[17,16,19,18,6],"name":"Drivetrain","customName":false,"deviceType":"Drivetrain","deviceClass":"smartdrive","setting":{"type":"4-motor","wheelSize":"wheel4in","gear":"ratio18_1","gearRatio":"1:1","direction":"fwd","gyroType":"inertial","width":"295","unit":"mm","wheelbase":"40","wheelbaseUnit":"mm","xOffset":"0","xOffsetUnit":"mm","yOffset":"0","yOffsetUnit":"mm","thetaOffset":"180"},"triportSourcePort":null},{"port":[1],"name":"SwingArm","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"true","fwd":"forward","rev":"reverse","gear":"ratio36_1"},"triportSourcePort":22},{"port":[8],"name":"RotationSens","customName":true,"deviceType":"Rotation","deviceClass":"rotation","setting":{"reversed":"false"},"triportSourcePort":22},{"port":[20],"name":"Intake","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio18_1"},"triportSourcePort":22},{"port":[],"name":"Controller1","customName":false,"deviceType":"Controller","deviceClass":"controller","setting":{"left":"","leftDir":"false","right":"","rightDir":"false","upDown":"","upDownDir":"false","xB":"","xBDir":"false","drive":"tank","id":"primary"},"triportSourcePort":22},{"port":[8],"name":"Clamp","customName":true,"deviceType":"DigitalOut","deviceClass":"digital_out","setting":{"id":"partner"},"triportSourcePort":22},{"port":[21],"name":"VisionSens","customName":true,"deviceType":"Vision","deviceClass":"vision","setting":{"config":"{\"config\":{\"brightness\":10,\"signatures\":[{\"name\":\"RED_RING\",\"parameters\":{\"uMin\":4477,\"uMax\":7521,\"uMean\":5999,\"vMin\":-365,\"vMax\":857,\"vMean\":246,\"rgb\":5518133,\"type\":0,\"name\":\"RED_RING\"},\"range\":2.5},{\"name\":\"SIG_2\",\"parameters\":{\"uMin\":0,\"uMax\":0,\"uMean\":0,\"vMin\":0,\"vMax\":0,\"vMean\":0,\"rgb\":0,\"type\":0,\"name\":\"SIG_2\"},\"range\":2.5},{\"name\":\"SIG_3\",\"parameters\":{\"uMin\":0,\"uMax\":0,\"uMean\":0,\"vMin\":0,\"vMax\":0,\"vMean\":0,\"rgb\":0,\"type\":0,\"name\":\"SIG_3\"},\"range\":2.5},{\"name\":\"SIG_4\",\"parameters\":{\"uMin\":0,\"uMax\":0,\"uMean\":0,\"vMin\":0,\"vMax\":0,\"vMean\":0,\"rgb\":0,\"type\":0,\"name\":\"SIG_4\"},\"range\":2.5},{\"name\":\"SIG_5\",\"parameters\":{\"uMin\":0,\"uMax\":0,\"uMean\":0,\"vMin\":0,\"vMax\":0,\"vMean\":0,\"rgb\":0,\"type\":0,\"name\":\"SIG_5\"},\"range\":2.5},{\"name\":\"SIG_6\",\"parameters\":{\"uMin\":0,\"uMax\":0,\"uMean\":0,\"vMin\":0,\"vMax\":0,\"vMean\":0,\"rgb\":0,\"type\":0,\"name\":\"SIG_6\"},\"range\":2.5},{\"name\":\"SIG_7\",\"parameters\":{\"uMin\":0,\"uMax\":0,\"uMean\":0,\"vMin\":0,\"vMax\":0,\"vMean\":0,\"rgb\":0,\"type\":0,\"name\":\"SIG_7\"},\"range\":2.5}],\"codes\":[]}}","isConfigured":"false"},"triportSourcePort":22},{"port":[1],"name":"Conveyor_Switch","customName":true,"deviceType":"LimitSwitch","deviceClass":"limit","setting":{"id":"partner"},"triportSourcePort":22},{"port":[2,10],"name":"Conveyor","customName":true,"deviceType":"MotorGroup","deviceClass":"motor_group","setting":{"fwd":"forward","rev":"reverse","gear":"ratio18_1","motor_a_reversed":"false","motor_b_reversed":"true"},"triportSourcePort":22}],"slot":0,"platform":"V5","sdkVersion":"20240802.15.00.00","appVersion":"4.0.8","minVersion":"3.1.0","fileFormat":"2.0.0","targetBrainGen":"First","v5Sounds":[{"name":"game over","url":"static/sounds/mixkit-arcade-retro-game-over-213.wav"}],"v5SoundsEnabled":false,"target":"Physical"}